# =============================================================================
# API BIBLIOTECA DIGITAL - Código comentado
# =============================================================================
# Aplicación FastAPI que simula un sistema de biblioteca: libros, usuarios
# y préstamos. Los datos se guardan en memoria (listas) para simplificar.
# =============================================================================

from datetime import date
# date se usa para obtener el año actual y validar que el año del libro sea <= hoy

from fastapi import FastAPI, HTTPException, Query
# FastAPI: framework web. HTTPException: para devolver errores HTTP. Query: parámetros en la URL

from fastapi.exceptions import RequestValidationError
# Se lanza cuando Pydantic rechaza el cuerpo de la petición (datos inválidos o faltantes)

from pydantic import BaseModel, Field, field_validator
# BaseModel: modelos con validación. Field: reglas por campo. field_validator: validadores custom

from typing import Literal
# Literal["a", "b"] restringe un tipo a solo esos valores (útil para estado del libro)

# -----------------------------------------------------------------------------
# Aplicación FastAPI
# -----------------------------------------------------------------------------
app = FastAPI(title="API Biblioteca Digital", version="1.0")
# Crea la instancia de la API. title y version aparecen en la documentación (/docs).


# -----------------------------------------------------------------------------
# Manejador global de errores de validación
# -----------------------------------------------------------------------------
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc: RequestValidationError):
    """
    Cuando el cliente envía datos que no pasan la validación de Pydantic
    (por ejemplo: título con 1 carácter, año 1000, email sin @), FastAPI
    devuelve por defecto 422 Unprocessable Entity. Este manejador hace que
    en su lugar se devuelva 400 Bad Request, como pide el enunciado.
    exc.errors() es la lista de errores que generó Pydantic.
    """
    from fastapi.responses import JSONResponse
    return JSONResponse(status_code=400, content={"detail": exc.errors()})


# -----------------------------------------------------------------------------
# Constantes y datos en memoria (simulan la "base de datos")
# -----------------------------------------------------------------------------

# Literal["disponible", "prestado"]: el tipo ESTADO_LIBRO solo acepta esos dos strings.
# Se usa en el modelo CrearLibro para que el estado del libro sea uno de los dos.
ESTADO_LIBRO = Literal["disponible", "prestado"]

# Lista de libros. Cada elemento es un diccionario con: id, titulo, autor, año, paginas, estado.
# estado indica si el libro está "disponible" para préstamo o ya "prestado".
libros = [
    {"id": 1, "titulo": "El principito", "autor": "Antoine de Saint-Exupéry", "año": 1943, "paginas": 96, "estado": "disponible"},
    {"id": 2, "titulo": "1984", "autor": "George Orwell", "año": 1949, "paginas": 328, "estado": "disponible"},
    {"id": 3, "titulo": "El alquimista", "autor": "Paulo Coelho", "año": 1988, "paginas": 208, "estado": "disponible"},
]

# Lista de usuarios registrados: id, nombre, email.
usuarios = [
    {"id": 1, "nombre": "Juan", "email": "juan@gmail.com"},
    {"id": 2, "nombre": "Maria", "email": "maria@gmail.com"},
    {"id": 3, "nombre": "Pedro", "email": "pedro@gmail.com"},
]

# Lista de préstamos. Cada préstamo vincula un libro con un usuario, tiene fechas
# y un flag "activo": True = aún prestado, False = ya devuelto (histórico).
prestamos = [
    {"id": 1, "libro_id": 1, "usuario_id": 1, "fecha_prestamo": "2026-01-01", "fecha_devolucion": "2026-01-05", "activo": True},
    {"id": 2, "libro_id": 2, "usuario_id": 2, "fecha_prestamo": "2026-01-02", "fecha_devolucion": "2026-01-06", "activo": False},
    {"id": 3, "libro_id": 3, "usuario_id": 3, "fecha_prestamo": "2026-01-03", "fecha_devolucion": "2026-01-07", "activo": True},
]

# Año actual: se usa en la validación del modelo CrearLibro (año del libro <= AÑO_ACTUAL).
AÑO_ACTUAL = date.today().year


# =============================================================================
# MODELOS PYDANTIC (esquemas de entrada y validación)
# =============================================================================

class CrearLibro(BaseModel):
    """
    Esquema para registrar un libro. Todos los campos se validan antes de entrar
    a la función del endpoint; si algo falla, se devuelve 400 (por el exception_handler).
    """
    id: int = Field(..., gt=0, description="Identificador de libro")
    # ... = obligatorio. gt=0 = greater than 0 (no se permite 0 ni negativos)

    titulo: str = Field(..., min_length=2, max_length=100, description="Título del libro")
    # Entre 2 y 100 caracteres (evita títulos vacíos o demasiado largos)

    autor: str = Field(..., min_length=2, max_length=100, description="Autor del libro")

    año: int = Field(..., gt=1450, le=AÑO_ACTUAL, description="Año de publicación")
    # gt=1450: mayor que 1450. le=AÑO_ACTUAL: less or equal = menor o igual al año actual

    paginas: int = Field(..., gt=1, description="Número de páginas")
    # Entero positivo mayor que 1 (al menos 2 páginas)

    estado: ESTADO_LIBRO = Field(default="disponible", description="Estado: disponible o prestado")
    # Solo acepta "disponible" o "prestado". Por defecto "disponible" si no se envía.

    @field_validator("estado", mode="before")
    @classmethod
    def estado_permitido(cls, v):
        """
        Validador personalizado: asegura que estado sea solo "disponible" o "prestado".
        mode="before" permite recibir el valor antes de que Pydantic lo convierta/valide.
        Si no es uno de los dos, lanza ValueError y la petición falla con 400.
        """
        if v not in ("disponible", "prestado"):
            raise ValueError('Estado debe ser "disponible" o "prestado"')
        return v


class CrearUsuario(BaseModel):
    """Esquema para registrar un usuario. Nombre y correo con validación."""
    id: int = Field(..., gt=0, description="Identificador de usuario")
    nombre: str = Field(..., min_length=2, max_length=100, description="Nombre del usuario")
    email: str = Field(..., min_length=5, max_length=100, description="Email válido")

    @field_validator("email")
    @classmethod
    def email_valido(cls, v: str):
        """
        Comprueba formato básico de email: debe contener @ y después del @
        debe haber al menos un punto (dominio tipo algo.com). Si no, ValueError → 400.
        """
        if "@" not in v or "." not in v.split("@")[-1]:
            raise ValueError("Correo electrónico no válido")
        return v


class CrearPrestamo(BaseModel):
    """
    Esquema para registrar un préstamo: qué libro (libro_id), qué usuario (usuario_id),
    fechas de préstamo y devolución. El campo "activo" se añade en el endpoint, no aquí.
    """
    id: int = Field(..., gt=0, description="Identificador del préstamo")
    libro_id: int = Field(..., gt=0, description="ID del libro")
    usuario_id: int = Field(..., gt=0, description="ID del usuario")
    fecha_prestamo: str = Field(..., description="Fecha de préstamo YYYY-MM-DD")
    fecha_devolucion: str = Field(..., description="Fecha de devolución YYYY-MM-DD")


# =============================================================================
# ENDPOINTS - LIBROS
# =============================================================================

@app.post("/v1/libros/", tags=["Libros"], status_code=201)
async def registrar_libro(libro: CrearLibro):
    """
    a) Registrar un libro.
    FastAPI deserializa el JSON del cuerpo de la petición al modelo CrearLibro;
    si la validación falla, no se llega aquí (respuesta 400 por el exception_handler).
    status_code=201: por defecto este endpoint responde con 201 Created.
    """
    # Evitar IDs duplicados: si ya existe un libro con ese id, 400.
    if any(lb["id"] == libro.id for lb in libros):
        raise HTTPException(status_code=400, detail="El id de libro ya existe")
    # model_dump() convierte el modelo Pydantic a diccionario para guardarlo en la lista.
    nuevo = libro.model_dump()
    libros.append(nuevo)
    return {"mensaje": "Libro creado", "datos": nuevo}


@app.get("/v1/libros/", tags=["Libros"])
async def listar_libros(disponibles_only: bool = Query(False, description="Solo libros disponibles")):
    """
    b) Listar libros. Si disponibles_only=true (query ?disponibles_only=true),
    solo se devuelven los que tienen estado "disponible". Si no, se devuelven todos.
    """
    lista = libros
    if disponibles_only:
        lista = [lb for lb in libros if lb.get("estado") == "disponible"]
    return {"total": len(lista), "libros": lista}


@app.get("/v1/libros/buscar", tags=["Libros"])
async def buscar_libro_por_nombre(nombre: str = Query(..., min_length=1)):
    """
    c) Buscar libro por nombre. Query(..., min_length=1) obliga a enviar nombre con al menos 1 carácter.
    La búsqueda es por coincidencia parcial y sin distinguir mayúsculas/minúsculas.
    """
    nombre_lower = nombre.lower().strip()
    encontrados = [lb for lb in libros if nombre_lower in lb["titulo"].lower()]
    return {"total": len(encontrados), "libros": encontrados}


# -----------------------------------------------------------------------------
# Funciones auxiliares (uso interno en los endpoints de préstamos)
# -----------------------------------------------------------------------------

def _libro_por_id(libro_id: int):
    """
    Busca un libro en la lista por su id. Devuelve el diccionario del libro
    o None si no existe. El guion bajo indica que es de uso interno del módulo.
    """
    for lb in libros:
        if lb["id"] == libro_id:
            return lb
    return None


def _prestamo_por_id(prestamo_id: int):
    """
    Busca un préstamo por id. Devuelve (índice_en_la_lista, diccionario_prestamo)
    o (None, None) si no existe. El índice sirve para modificar o eliminar ese elemento.
    """
    for i, p in enumerate(prestamos):
        if p["id"] == prestamo_id:
            return i, p
    return None, None


# =============================================================================
# ENDPOINTS - PRÉSTAMOS
# =============================================================================

@app.post("/v1/prestamos/", tags=["Préstamos"], status_code=201)
async def registrar_prestamo(prestamo: CrearPrestamo):
    """
    d) Registrar el préstamo de un libro a un usuario.
    - 400 si el libro no existe, el usuario no existe o el id de préstamo ya existe.
    - 409 Conflict si el libro ya está prestado (estado "prestado").
    - 201 Created si todo es correcto: se añade el préstamo y el libro pasa a "prestado".
    """
    libro = _libro_por_id(prestamo.libro_id)
    if not libro:
        raise HTTPException(status_code=400, detail="Libro no encontrado")
    if libro.get("estado") == "prestado":
        raise HTTPException(status_code=409, detail="El libro ya está prestado")
    if any(p["id"] == prestamo.id for p in prestamos):
        raise HTTPException(status_code=400, detail="El id de préstamo ya existe")
    if not any(u["id"] == prestamo.usuario_id for u in usuarios):
        raise HTTPException(status_code=400, detail="Usuario no encontrado")

    nuevo = prestamo.model_dump()
    nuevo["activo"] = True  # préstamo recién creado = aún activo (no devuelto)
    prestamos.append(nuevo)
    # Actualizar el estado del libro a "prestado" en la lista libros
    for lb in libros:
        if lb["id"] == prestamo.libro_id:
            lb["estado"] = "prestado"
            break
    return {"mensaje": "Préstamo registrado", "datos": nuevo}


@app.put("/v1/prestamos/{prestamo_id}/devolver", tags=["Préstamos"])
async def marcar_libro_devuelto(prestamo_id: int):
    """
    e) Marcar un libro como devuelto.
    - 409 si el préstamo no existe o ya fue marcado como devuelto (activo=False).
    - 200 OK: se pone activo=False en el préstamo y el libro vuelve a estado "disponible".
    """
    idx, prestamo = _prestamo_por_id(prestamo_id)
    if prestamo is None:
        raise HTTPException(status_code=409, detail="El registro de préstamo no existe")
    if not prestamo.get("activo", True):
        raise HTTPException(status_code=409, detail="El préstamo ya fue devuelto")

    prestamo["activo"] = False
    prestamos[idx] = prestamo
    for lb in libros:
        if lb["id"] == prestamo["libro_id"]:
            lb["estado"] = "disponible"
            break
    return {"mensaje": "Libro devuelto correctamente", "prestamo_id": prestamo_id}


@app.delete("/v1/prestamos/{prestamo_id}", tags=["Préstamos"])
async def eliminar_prestamo(prestamo_id: int):
    """
    f) Eliminar el registro de un préstamo.
    - 409 si el registro no existe.
    - 200 OK: se quita el préstamo de la lista. Si el préstamo estaba activo,
      el libro asociado vuelve a "disponible".
    """
    idx, prestamo = _prestamo_por_id(prestamo_id)
    if prestamo is None:
        raise HTTPException(status_code=409, detail="El registro de préstamo no existe")

    libro_id = prestamo["libro_id"]
    prestamos.pop(idx)  # eliminar por índice para no dejar huecos
    if prestamo.get("activo", True):
        for lb in libros:
            if lb["id"] == libro_id:
                lb["estado"] = "disponible"
                break
    return {"mensaje": "Préstamo eliminado", "prestamo_id": prestamo_id}


# =============================================================================
# ENDPOINTS - USUARIOS Y CONSULTA DE PRÉSTAMOS
# =============================================================================

@app.get("/v1/usuarios/", tags=["Usuarios"])
async def leer_usuarios():
    """Devuelve la lista de todos los usuarios registrados."""
    return {"total": len(usuarios), "usuarios": usuarios}


@app.post("/v1/usuarios/", tags=["Usuarios"], status_code=201)
async def registrar_usuario(usuario: CrearUsuario):
    """Registra un nuevo usuario. 400 si el id ya existe."""
    if any(u["id"] == usuario.id for u in usuarios):
        raise HTTPException(status_code=400, detail="El id de usuario ya existe")
    nuevo = usuario.model_dump()
    usuarios.append(nuevo)
    return {"mensaje": "Usuario creado", "datos": nuevo}


@app.get("/v1/prestamos/", tags=["Préstamos"])
async def leer_prestamos():
    """Devuelve la lista de todos los préstamos (activos e históricos)."""
    return {"total": len(prestamos), "prestamos": prestamos}
